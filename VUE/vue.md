[分享度小满的前端面经，考 Vue 考的比较多](https://mp.weixin.qq.com/s/wKwWMll0qoTDFsjKknpHPg)
[每个人都需要掌握的「Vue2」50 个知识点](https://mp.weixin.qq.com/s/rqoZ5KWqT_1QAx91bJMeIg)
[Vue 中的虚拟 dom 和 diff 算法知多少](https://mp.weixin.qq.com/s/xyKupyyVvEUZoTytV0Xg4g)
[《VUE 组件之间数据传递全集》](https://juejin.im/entry/5ba215ac5188255c6d0d8345)
[剖析 Vue 原理&实现双向绑定 MVVM](https://segmentfault.com/a/1190000006599500)
[一文搞定常考 Vuex 常考的知识点](https://mp.weixin.qq.com/s/S7r3H2mvtFAxoJovk-oA5A)
[一文搞定常考 Vue-router 知识点](https://mp.weixin.qq.com/s/bp2LebO1yO8_VmRW4kMD9w)
[VUE 干货分享](https://m.zhipin.com/mpa/html/get/column?contentId=9b2b571e4263412dqxB50tq_&identity=0&userId=121667415)

[最全的 Vue 面试题+详解答案](https://juejin.cn/post/6961222829979697165)

#### 一、Vue 组件间的参数传递方式？

```
（1）父子组件间通信

第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。

第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。

第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。

（2）兄弟组件间通信

第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。

第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。

（3）任意组件之间

使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。

如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。
```

详细资料可以参考：
[《VUE 组件之间数据传递全集》](https://juejin.im/entry/5ba215ac5188255c6d0d8345)

#### 二、 computed 和 watch 的差异？

```
（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。

（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。

（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。
```

```
computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的 属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。
watch 侦听器 : 更多的是观察的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。
运用场景：
当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed的缓存特性,避免每次获取值时,都要重新计算。
当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率, 并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。
多个因素影响一个显示，用computed；一个因素的变化影响多个其他因素、显示，用watch;
computed 和 methods 的区别:
computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值;
method：只要发生重新渲染，method 调用总会执行该函数

```

#### 三、vue 双向数据绑定原理？

```
vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。

首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。

数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。

如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。

如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。
```

[剖析 Vue 原理&实现双向绑定 MVVM](https://segmentfault.com/a/1190000006599500)

#### 四、vuex

```
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态。
有五种，State、 Getter、Mutation 、Action、 Module
state： 基本数据(数据源存放地)
getters： 从基本数据派生出来的数据
mutations ： 提交更改数据的方法，同步！
actions ： 像一个装饰器，包裹mutations，使之可以异步。
modules ： 模块化Vuex

```

#### 五、 vue 中 key 值的作用？

```
vue 中 key 值的作用可以分为两种情况来考虑。

第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。

第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，可以避免就地复用的情况，以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。
```

#### 六、vue 的生命周期

- 1、Vue 的生命周期是什么？

```
Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。
```

- 2、vue 生命周期的作用是什么？

```
它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。
```

- 3、vue 生命周期总共有几个阶段？

```
它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。
```

- 4、第一次页面加载会触发哪几个钩子？

```
会触发 下面这几个 beforeCreate, created, beforeMount, mounted 。
```

- 5、DOM 渲染在 哪个周期中就已经完成？

```
DOM 渲染在 mounted 中就已经完成了。
```

- 6、Vue 的各个生命阶段是什么？

```
Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。

（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。

（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。

（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。

（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。

（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。

（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。

（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。

（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。
```

#### 七、vue 常用指令

```
v-model 多用于表单元素实现双向数据绑定（同angular中的ng-model）
v-bind 动态绑定 作用： 及时对页面的数据进行更改
v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面
v-for 格式： v-for=“字段名 in(of) 数组json” 循环数组或json(同angular中的ng-repeat)
v-show 显示内容 （同angular中的ng-show）
v-hide 隐藏内容（同angular中的ng-hide）
v-if 显示与隐藏 （dom元素的删除添加 同angular中的ng-if 默认值为false）
v-else-if 必须和v-if连用
v-else 必须和v-if连用 不能单独使用 否则报错 模板编译错误
v-text 解析文本
v-html 解析html标签
v-bind:class 三种绑定方法
对象型 '{red:isred}'
三元型 'isred?"red":"blue"'
数组型 '[{red:"isred"},{blue:"isblue"}]'
v-once 进入页面时 只渲染一次 不在进行渲染
v-cloak 防止闪烁
v-pre 把标签内部的元素原位输出

```

#### 八、diff 算法的作用

```
Diff算法的作用是用来计算出Virtual DOM（虚拟DOM）中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。
	包括几个步骤：
1)	用javaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中；
2)	当状态变更的时候，重新构造一个新的对象树，然后用新的树和旧的树进行比较，记录两个树的差异；
3)	把所记录的差异应用到所构建的真正的DOM树上，视图就更新了。

```

#### 九、v-show 和 v-if 指令的共同点和不同点

```
共同点：都是动态显示 DOM 元素
区别点：
v-if 是动态的向 DOM 树内添加或者删除 DOM 元素
v-show 是通过设置 DOM 元素的 display 样式属性控制显隐
v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件
v-show 只是简单的基于 css 切换
性能消耗：
v-if 有更高的切换消耗
v-show 有更高的初始渲染消耗
使用场景：
v-if 适合运营条件不大可能改变
v-show 适合频繁切换
```

#### 十、谈一谈你对 nextTick 的理解？

```
在下次DOM更新循环结束之后执行的延迟回调。

当你修改了 data 的值然后马上获取相关dom元素的值，是不能获取到更新后的值，你需要使用$nextTick 这个回调，让修改后的 data 值渲染更新到 dom 元素之后在获取，才能成功。

nextTick 接收一个回调函数作为参数，并将这个回调函数延迟到DOM更新后才执行；
使用场景：想要操作 基于最新数据的生成DOM 时，就将这个操作放在 nextTick 的回调中。

nextTick 实现原理
将传入的回调函数包装成异步任务，异步任务又分微任务和宏任务，为了尽快执行所以优先选择微任务；
nextTick 提供了四种异步方法 Promise.then、MutationObserver、setImmediate、setTimeOut(fn,0)

```

#### 十一、vue 组件中 data 为什么必须是一个函数？

```
因为 javaScript 的特性所导致，在 component 中，data 必须以函数的形式存在，不可以是对象。
组件中的 data 写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 data，相当于每个组件实例都有自己私有的数据空间，他们只负责各自维护数据，不会造成混乱。而单纯的写成对象形式，就是所有组件实例共用了一个 data，这样改一个全部都会修改。
```

#### 十二、谈谈对 keep-alive 的了解

```
是VUE提供的一个组件，可以用来缓存组件，会带来性能的提升。
<keep-alive> 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。
在平常开发中，有部分组件没有必要多次初始化，这时，我们需要将组件进行持久化，是组件的状态维持不变，在下一次展示时，也不会进行初始化组件。也就是说，keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，或者避免重新渲染，也就是所谓的组件缓存。
```

#### 十三、scoped 原理

```
1.作用：让样式在本组件中生效，不能影响其他组件
2.原理：给节点新增自定义属性（data-v-XXXXX）,然后 css 根据属性选择器添加样式
```

#### 十四、怎么理解 Vue 单向数据流？

```
父组件传输props给子组件时，子组件只能使用而不能修改，这是为了组件之间能更高地去解耦。比如有一个父组件，传 props 给 10 个子组件，如果某一个子组件修改了，那么会影响其他 9 个子组件跟着刷新，所以不推荐子组件修改 props
```

#### 十五、自定义指令写过么，自定义指令都有哪些钩子？

```
Vue2
bind：指令绑定到指定元素时触发，只触发一次
inserted：指定元素插入到 DOM 时触发，只触发一次
update：VNode 更新时触发，会触发多次
unbind：指令解绑时触发，只触发一次
```

```
Vue3
created：指定元素的 attribute 或事件监听器被应用之前被调用
beforeMount：指令绑定到指定元素上触发
mounted：指定元素被挂载时触发
beforeUpdate：在更新包含组件的 VNode 之前触发
updated：在包含组件的 VNode 及其 VNode 更新后调用
beforeUnMount：在卸载指定元素的父组件之前触发
unmounted：指令解绑时触发
```

#### 十六、Vue2 的数据响应式有两个缺陷，你知道是哪两个缺陷么，为什么会有这样的缺陷，如何解决？

```
1、对象新增属性或修改新增的属性时，无法触发视图更新，需要使用 Vue.set，对象删除属性时需要使用 Vue.delete 才能触发更新
2、数组直接通过下标修改元素无法触发视图更新，需要使用数组的方法 splice、push 等等
```

#### 十七、Vue 如何实现的数组的监听，为什么 Vue 没有对数组下标修改做劫持？

```
Vue2是通过重写了数组原型上的方法来达到对数组的修改的监听，Vue2没有对数组下标做劫持，是出于性能的考虑，因为通常数组元素都是非常多的，可能成百上千，如果每个元素都进行劫持，则非常耗费性能。
```

#### 十八、Vue 响应式是怎么实现的？

```
1、劫持：通过 Object.defineProperty 对对象进行递归劫持属性的 get、set
2、观察者模式：使用 watcher 进行观察数据使用的地方
3、发布订阅模式：使用 dep 收集 watcher，数据更改时，通过 notify 方法通知 dep 里的 watcher 去进行相应的更新
4、数组：数组没有使用劫持的模式，而是通过重写数组原型上的方法，来实现数组的响应式
```

#### 十九、说说 虚拟 dom 和 diff 算法 吧？

```
虚拟 dom：
虚拟 dom 是一个对象，一个描述真实 DOM 的对象，每次数据更新时，新旧虚拟 DOM 都会互相进行同层对比，而 diff 算法优化就是在此时做优化的。

diff 算法：
第一步：调用 patch 方法，传入新旧虚拟 DOM，开始同层对比
第二步：调用 isSameNode 方法，对比新旧节点是否同类型节点
第三步：如果不同，新节点直接代替旧节点
第四步：如果相同，调用 patchNode 进行对比节点
如果旧节点和新节点都是文本节点，则新文本代替旧文本
如果旧节点有子节点，新节点没，则删除旧节点的子节点
如果旧节点没有子节点，新节点有，则把子节点新增上去
如果都有子节点，则调用 updateChildren 方法进行新旧子节点的对比
子节点对比为首尾对比法
```

#### 二十、如果子组件改变 props 里的数据会发生什么？

```
基础类型：如果父传给子的是基础类型，修改则会报错
引用类型：如果父传给子的是引用类型，修改属性则会同时修改父组件数据
```

#### 二十一、如何将获取 data 中某一个数据的初始状态？

使用 this.$options.data().xxx 获取初始值

#### 二十二、router.push、router.replace、router.go 的区别？

router.push：跳转，并向 history 栈中加一个记录，可以后退到上一个页面
router.replace：跳转，不会向 history 栈中加一个记录，不可以后退到上一个页面
router.go：传正数向前跳转，传负数向后跳转

#### 二十三、keep-alive 的作用是什么

主要是用于需要频繁切换的组件时进行缓存，不需要重新渲染页面

#### 二十四、加入了 keep-alive 会多那两个生命周期？

activated：页面第一次进入的时候，钩子触发顺序是 created->mounted->activated
deactivated：页面退出的时侯会触发 deactivated,当再次前进或者后退的时候只触发 activated

#### 二十五、父组件和子组件生命周期钩子执行顺序是什么？

加载渲染过程：
父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
子组件更新过程：
父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
父组件更新过程：
父 beforeUpdate -> 父 updated
销毁过程：
父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

#### 二十六、首屏加载空白的解决方案？

单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的 js 文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏。
解决办法：
优化 webpack 减少模块打包体积，code-split 按需加载服务端渲染；
在服务端事先拼装好首页所需的 html ；
首页加 loading 或 骨架屏 （仅仅是优化体验）；
服务端开启 gzip 压缩；
打包文件分包，提取公共文件包；

#### 二十七、mvvm 和 mvc 的区别

MVVM 即 Model-View-ViewModel 的简写。即模型-视图-视图模型。模型（Model）指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型(ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。
MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑。使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。MVC 和 MVVM 的区别并不是 VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念，ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。

#### 二十八、eventbus 事件中兄弟组件传值原理

概念 EventBus 是消息传递的一种方式，基于一个消息中心，订阅和发布消息的模式，称为发布订阅者模式。on('name', fn)订阅消息，name:订阅的消息名称， fn: 订阅的消息 emit('name', args)发布消息, name:发布的消息名称 ， args：发布的消息 eventbus 应用，详情见 eventbus 使用详情介绍注：只不过在 vue 中已经替我们实现好了$emit,$on 这些方法，所以直接用的时候去 new Vue()就可以了.
